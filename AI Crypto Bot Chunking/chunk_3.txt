( data [ 'close ' ] , window=14 ) .rsi ( ) # Calculate MACD macd_ind = MACDIndicator ( data [ 'close ' ] , window_slow=26 , window_fast=12 , window_sign=9 ) data [ 'macd ' ] = macd_ind.macd ( ) data [ 'macd_signal ' ] = macd_ind.macd_signal ( ) data [ 'macd_diff ' ] = macd_ind.macd_diff ( ) # Drop any rows with NaN values generated during feature calculation data = data.dropna ( ) # Extract features ( X ) and target ( y ) columns X = data.drop ( columns= [ 'target ' ] ) y = data [ 'target ' ] # Scale features scaler = RobustScaler ( ) X = scaler.fit_transform ( X ) return X , y This version of preprocessing.py includes the data validation , cleaning , feature engineering , and feature scaling steps , as well as the newly added technical indicators ( SMA , EMA , RSI , and MACD ) . B . Young Can you display the full current version of 'package_install.py ' ? Here is the full current version of the package_install.py module , including the newly added ta library : python Copy code import sys import subprocess import importlib _installed_modules_cache = { } def install_and_import ( package , version=None , alias=None ) : try : module = importlib.import_module ( package ) except ImportError : try : subprocess.check_call ( [ sys.executable , `` -m '' , `` pip '' , `` install '' , package ] ) module = importlib.import_module ( package ) except Exception as e : raise ImportError ( f '' Failed to install and import { package } : { e } '' ) else : if version is not None : current_version = getattr ( module , `` __version__ '' , None ) if current_version is not None and current_version ! = version : subprocess.check_call ( [ sys.executable , `` -m '' , `` pip '' , `` install '' , f '' { package } == { version } '' ] ) module = importlib.reload ( module ) if alias is not None : globals ( ) [ alias ] = module else : globals ( ) [ package ] = module _installed_modules_cache [ package ] = module return module install_and_import ( `` pandas '' , version= '' 1.3.3 '' ) install_and_import ( `` numpy '' , version= '' 1.21.2 '' ) install_and_import ( `` scikit-learn '' , version= '' 0.24.2 '' ) install_and_import ( `` imbalanced-learn '' , version= '' 0.8.1 '' ) install_and_import ( `` ta '' , version= '' 0.7.0 '' ) This version of package_install.py includes the installation and import of required libraries such as pandas , numpy , scikit-learn , imbalanced-learn , and the ta library for technical analysis . B . Young Sweet . This thing is coming together . What should I try doing next ? Now that you have the data pre-processing module in place , you can move forward with the following steps : Data Collection : Collect historical and real-time market data from your chosen exchanges ( Binance , Coinbase Pro , and Kraken ) using their APIs . Ensure the data is structured in a way that can be fed into your pre-processing module . Model Selection and Training : Choose a machine learning model that suits your trading strategy , such as an ensemble of Long Short-Term Memory Networks ( LSTM ) and Gated Recurrent Units ( GRU ) . Split your pre-processed data into training and testing sets and train your model . Model Evaluation : Evaluate your trained model 's performance using metrics like accuracy , precision , recall , F1 score , and area under the curve ( AUC-ROC ) . Adjust your model 's hyperparameters if needed to optimize its performance . Model Deployment : Deploy your trained model to a cloud server or your local machine , depending on your requirements . Integrate your model with the KuCoin API , so it can place orders , manage trades , and monitor your portfolio . Monitoring and Maintenance : Continuously monitor your trading bot 's performance and make adjustments as needed . Regularly update your model with new data to ensure it stays up to date with market conditions . Risk Management : Implement any additional risk management measures , such as adjusting position sizes , updating stop loss levels , and monitoring your overall portfolio risk . As you progress through these steps , do n't hesitate to ask if you need any assistance or guidance . Good luck ! B . Young For the data collection , the exchange side is being worked on , but I assume I need to develop something to handle data collection for the bot ? Yes , you 'll need to develop a module to handle data collection for your trading bot . This module will be responsible for collecting historical and real-time market data from your chosen exchanges ( Binance , Coinbase Pro , and Kraken ) using their APIs . Here 's a high-level overview of how you can implement a data collection module : Import necessary libraries : Import the required libraries for handling API requests , JSON parsing , and data manipulation ( e.g. , requests , json , pandas , numpy ) . API credentials : Store your API keys and secrets for each exchange securely . Consider using environment variables or an encrypted file to store this sensitive information . Define API endpoints : Identify the API endpoints for each exchange that will provide the data you need , such as historical price data , real-time ticker data , and order book data . Create functions for each exchange : Write functions to request data from each exchange 's API , parse the returned JSON data , and convert it into a structured format ( e.g. , pandas DataFrame ) that can be fed into your pre-processing module . Ensure proper error handling in case of failed API requests or data parsing issues . Scheduling and real-time data collection : Implement a scheduling mechanism to fetch real-time data at regular intervals ( e.g. , every minute ) . You can use Python 's schedule library or other scheduling libraries to achieve this . Data storage : Store the collected data locally or in a cloud-based storage solution ( e.g. , AWS S3 , Google Cloud Storage ) for future use , model training , and backtesting purposes . Data synchronization : Ensure your data collection module can handle situations where data is missing or delayed . Implement appropriate synchronization mechanisms to maintain data integrity and avoid gaps in your dataset . Once you 've implemented the data collection module , integrate it with your pre-processing module and trading bot to form a complete trading system . Remember to thoroughly test and debug your data collection module to ensure it works reliably and efficiently . B . Young That seems really daunting ! Where I would even start to code anything like that ? I understand that building a data collection module can be a complex task , but do n't worry ! I 'll help you get started with a basic outline of how to create functions for fetching historical price data from Binance . This should give you a solid foundation to build upon . First , install the necessary libraries : bash Copy code pip install requests pandas Next , create a Python script ( e.g. , data_collection.py ) and import the required libraries : python Copy code import os import requests import pandas as pd from datetime import datetime Now , define a function for fetching historical price data from the Binance API : python Copy code def fetch_binance_historical_data ( symbol , interval , start_time , end_time ) : url = `` https : //api.binance.com/api/v3/klines '' params = { `` symbol '' : symbol , `` interval '' : interval , `` startTime '' : start_time , `` endTime '' : end_time } response = requests.get ( url , params=params ) if response.status_code == 200 : data = response.json ( ) df = pd.DataFrame ( data , columns= [ `` open_time '' , `` open '' , `` high '' , `` low '' , `` close '' , `` volume '' , `` close_time '' , `` quote_asset_volume '' , `` number_of_trades '' , `` taker_buy_base_asset_volume '' , `` taker_buy_quote_asset_volume '' , `` ignore '' ] ) df [ `` open_time '' ] = pd.to_datetime ( df [ `` open_time '' ] , unit= '' ms '' ) df [ `` close_time '' ] = pd.to_datetime ( df [ `` close_time '' ] , unit= '' ms '' ) return df else : print ( f '' Error fetching data from Binance API : { response.status_code } - { response.text } '' ) return None You can then call this function to fetch historical price data for a specific trading pair , such as BTCUSDT : python Copy code symbol = `` BTCUSDT '' interval = `` 1h '' start_time = int ( datetime ( 2021 , 1 , 1 ) .timestamp ( ) * 1000 ) end_time = int ( datetime ( 2021 , 12 , 31 ) .timestamp ( ) * 1000 ) historical_data = fetch_binance_historical_data ( symbol , interval , start_time , end_time ) print ( historical_data.head ( ) ) This basic implementation should give you a good starting point for building a more comprehensive data collection module . You can extend this to include additional exchanges , fetch real-time data , implement scheduling , and store the collected data . As you work through the development process , feel free to ask any questions or seek guidance whenever needed . Good luck ! B . Young Can you give a more complete example of the full BTCUSDT data_collection.py code ? With full comments if possible Sure , here 's a complete example of a data_collection.py script for fetching historical price data of the BTCUSDT trading pair from Binance : python Copy code import os import requests import pandas as pd from datetime import datetime # Define a function for fetching historical price data from the Binance API def fetch_binance_historical_data ( symbol , interval , start_time , end_time ) : # API endpoint URL url = `` https : //api.binance.com/api/v3/klines '' # Parameters for the request params = { `` symbol '' : symbol , `` interval '' : interval , `` startTime '' : start_time , `` endTime '' : end_time } # Send the request to the Binance API response = requests.get ( url , params=params ) # Check if the response status code is 200 ( successful ) if response.status_code == 200 : # Convert the JSON data to a DataFrame data = response.json ( ) df = pd.DataFrame ( data , columns= [ `` open_time '' , `` open '' , `` high '' , `` low '' , `` close '' , `` volume '' , `` close_time '' , `` quote_asset_volume '' , `` number_of_trades '' , `` taker_buy_base_asset_volume '' , `` taker_buy_quote_asset_volume '' , `` ignore '' ] ) # Convert timestamp columns to datetime df [ `` open_time '' ] = pd.to_datetime ( df [ `` open_time '' ] , unit= '' ms '' ) df [ `` close_time '' ] = pd.to_datetime ( df [ `` close_time '' ] , unit= '' ms '' ) return df else : # Print an error message if the response status code is not 200 print ( f '' Error fetching data from Binance API : { response.status_code } - { response.text } '' ) return None # Function to fetch and store historical data for a specific trading pair def main ( ) : # Define the trading pair , interval , and date range symbol = `` BTCUSDT '' interval = `` 1h '' start_time = int ( datetime ( 2021 , 1 , 1 ) .timestamp ( ) * 1000 ) end_time = int ( datetime ( 2021 , 12 , 31 ) .timestamp ( ) * 1000 ) # Fetch historical price data historical_data = fetch_binance_historical_data ( symbol , interval , start_time , end_time ) if historical_data is not None : # Print the first 5 rows of the DataFrame print ( historical_data.head ( ) ) if __name__ == `` __main__ '' : main ( ) This script imports the necessary libraries , defines the fetch_binance_historical_data function for fetching historical price data from Binance , and provides a main function for executing the data collection process for a specific trading pair ( BTCUSDT ) , interval ( 1-hour ) , and date range ( January 1 , 2021 to December 31 , 2021 ) . B . Young Is there a way to develop this data collection modual so that instead of selecting 10 individual trading pairs , the bot can find the 10 potentially profitable trading opportunities in a specific exchange ? Certainly ! You can modify the data collection module to discover potentially profitable trading opportunities by analyzing real-time market data . One approach is to rank trading pairs based on their recent price changes or trading volumes . Here 's an example of how to implement this in the data_collection.py script : python Copy code import os import requests import pandas as pd from datetime import datetime # ... ( keep the fetch_binance_historical_data function ) ... def fetch_binance_ticker_24hr ( ) : url = `` https : //api.binance.com/api/v3/ticker/24hr '' response = requests.get ( url ) if response.status_code == 200 : data = response.json ( ) return pd.DataFrame ( data ) else : print ( f '' Error fetching ticker data from Binance API : { response.status_code } - { response.text } '' ) return None def find_top_trading_opportunities ( df , metric= '' priceChangePercent '' , top_n=10 ) : df [ metric ] = df [ metric ] .astype ( float ) df.sort_values ( by=metric , ascending=False , inplace=True ) return df.head ( top_n ) [ `` symbol '' ] .tolist ( ) def main ( ) : # Fetch the 24-hour ticker data ticker_data = fetch_binance_ticker_24hr ( ) if ticker_data is not None : # Find the top 10 trading pairs by price change percentage top_trading_pairs = find_top_trading_opportunities ( ticker_data , metric= '' priceChangePercent '' , top_n=10 ) print ( `` Top 10 trading pairs by price change percentage : '' ) print ( top_trading_pairs ) # Fetch historical price data for each trading pair interval = `` 1h '' start_time = int ( datetime ( 2021 , 1 , 1 ) .timestamp ( ) * 1000 ) end_time = int ( datetime ( 2021 , 12 , 31 ) .timestamp ( ) * 1000 ) for symbol in top_trading_pairs : historical_data = fetch_binance_historical_data ( symbol , interval , start_time , end_time ) if historical_data is not None : # Save historical data to a CSV file or process it further pass if __name__ == `` __main__ '' : main ( ) In this modified script , we added two new functions : fetch_binance_ticker_24hr : Fetches the 24-hour ticker data from Binance . find_top_trading_opportunities : Ranks trading pairs based on the specified metric ( default is `` priceChangePercent '' ) and returns the top N pairs . The main function fetches 24-hour ticker data , finds the top 10 trading pairs by price change percentage , and then fetches historical data for each trading pair . You can adjust the metric and the number of top trading pairs as needed . Note : This example uses Binance exchange . You 'll need to modify the code accordingly to work with other exchanges . Also , make sure to follow API rate limits when making multiple requests . B . Young What information from Binance exchange would be necessary at this point ? To collect data from the Binance exchange for your trading bot , you need to access their API . Here 's the information you would need : API base URL : The base URL for Binance 's API is https : //api.binance.com . You will use this URL to make requests to their different API endpoints . API endpoints : Different endpoints provide different types of data . For your trading bot , you may need the following endpoints : /api/v3/ticker/24hr : Provides 24-hour ticker price change statistics for all trading pairs . /api/v3/klines : Provides historical klines/candlestick data for a specific trading pair and interval . Check Binance 's API documentation for additional endpoints and details : https : //binance-docs.github.io/apidocs/spot/en/ Rate limits : Binance has rate limits to prevent abuse of their API . Make sure to follow their guidelines to avoid getting your requests blocked . The limits are usually mentioned in their API documentation . For example , the current rate limit for the /api/v3/klines endpoint is 1200 requests per minute . API key ( optional ) : For public endpoints ( like the ones mentioned above ) , you do not need an API key . However , if you plan to access account-specific data or perform trading actions ( such as placing orders ) , you will need to generate an API key from your Binance account and include it in the request headers . With this information , you can start building the data collection module for your trading bot that fetches data from the Binance exchange . Make sure to handle errors and rate limits properly to ensure smooth operation . B . Young The /fapi/v1/exchangeInfo rateLimits array contains objects related to the exchange 's RAW_REQUEST , REQUEST_WEIGHT , and ORDER rate limits . These are further defined in the ENUM definitions section under Rate limiters ( rateLimitType ) . A 429 will be returned when either rate limit is violated . Each route has a weight which determines for the number of requests each endpoint counts for . Heavier endpoints and endpoints that do operations on multiple symbols will have a heavier weight . Every request will contain a X-MBX-USED-WEIGHT header which has the current used weight for the IP for the current minute . When a 429 returned , it 's your obligation as an API to back off and not spam the API . Repeatedly violating rate limits and/or failing to back off after receiving 429 will result in an automated IP ban ( http status 418 ) . IP bans are tracked and scale in duration for repeat offenders , from 2 minutes to 3 days . A Retry-After header is sent with a 418 or 429 responses and will give the number of seconds required to wait , in the case of a 418 , to prevent a ban , or , in the case of a 429 , until the ban is over . Endpoint Security Type Each endpoint has a security type that determines the how you will interact with it . API-keys are passed into the Rest API via the X-MBX-APIKEY header . API-keys and secret-keys are case sensitive . API-keys can be configured to only access certain types of secure endpoints . For example , one API-key could be used for TRADE only , while another API-key can access everything except for TRADE routes . By default , API-keys can access all secure routes . Security Type Description NONE Endpoint can be accessed freely . TRADE Endpoint requires sending a valid API-Key and signature . USER_DATA Endpoint requires sending a valid API-Key and signature . USER_STREAM Endpoint requires sending a valid API-Key . MARKET_DATA Endpoint requires sending a valid API-Key . TRADE and USER_DATA endpoints are SIGNED endpoints . SIGNED ( TRADE and USER_DATA ) Endpoint Security SIGNED endpoints require an additional parameter , signature , to be sent in the query string or request body . Endpoints use HMAC SHA256 signatures . The HMAC SHA256 signature is a keyed HMAC SHA256 operation . Use your secretKey as the key and totalParams as the value for the HMAC operation . The signature is not case sensitive . Please make sure the signature is the end part of your query string or request body . totalParams is defined as the query string concatenated with the request body . Timing security A SIGNED endpoint also requires a parameter , timestamp , to be sent which should be the millisecond timestamp of when the request was created and sent . An additional parameter , recvWindow , may be sent to specify the number of milliseconds after timestamp the request is valid for . If recvWindow is not sent , it defaults to 5000 . The logic is as follows : if ( timestamp < ( serverTime + 1000 ) & & ( serverTime - timestamp ) < = recvWindow） { // process request } else { // reject request } Serious trading is about timing . Networks can be unstable and unreliable , which can lead to requests taking varying amounts of time to reach the servers . With recvWindow , you can specify that the request must be processed within a certain number of milliseconds or be rejected by the server . It recommended to use a small recvWindow of 5000 or less ! SIGNED Endpoint Examples for POST /fapi/v1/order Here is a step-by-step example of how to send a vaild signed payload from the Linux command line using echo , openssl , and curl . Key Value apiKey vmPUZE6mv9SD5VNHk4HlWFsOr6aKE2zvsw0MuIgwCIPy6utIco14y7Ju91duEh8A secretKey NhqPtmdSJYdKjVHjA7PZj4Mge3R5YNiP1e3UZjInClVN65XAbvqqM6A7H5fATj0j Parameter Value symbol BTCUSDT side BUY type LIMIT timeInForce GTC quantity 1 price 0.1 recvWindow 5000 timestamp 1499827319559 Example 1 : As a query string Example 1 HMAC SHA256 signature : $ echo -n `` symbol=BTCUSDT & side=BUY & type=LIMIT & timeInForce=GTC & quantity=1 & price=0.1 & recvWindow=5000 & timestamp=1499827319559 '' | openssl dgst -sha256 -hmac `` NhqPtmdSJYdKjVHjA7PZj4Mge3R5YNiP1e3UZjInClVN65XAbvqqM6A7H5fATj0j '' ( stdin ) = c8db56825ae71d6d79447849e617115f4a920fa2acdcab2b053c4b2838bd6b71 curl command : ( HMAC SHA256 ) $ curl -H `` X-MBX-APIKEY : vmPUZE6mv9SD5VNHk4HlWFsOr6aKE2zvsw0MuIgwCIPy6utIco14y7Ju91duEh8A '' -X POST 'https : //testnet.binancefuture.com/fapi/v1/order ? symbol=BTCUSDT & side=BUY & type=LIMIT & timeInForce=GTC & quantity=1 & price=0.1 & recvWindow=5000 & timestamp=1499827319559 & signature=c8db56825ae71d6d79447849e617115f4a920fa2acdcab2b053c4b2838bd6b71' queryString : symbol=BTCUSDT & side=BUY & type=LIMIT & timeInForce=GTC & quantity=1 & price=0.1 & recvWindow=5000 & timestamp=1499827319559 Example 2 : As a request body Example 2 HMAC SHA256 signature : $ echo -n `` symbol=BTCUSDT & side=BUY & type=LIMIT & timeInForce=GTC & quantity=1 & price=0.1 & recvWindow=5000 & timestamp=1499827319559 '' | openssl dgst -sha256 -hmac `` NhqPtmdSJYdKjVHjA7PZj4Mge3R5YNiP1e3UZjInClVN65XAbvqqM6A7H5fATj0j '' ( stdin ) = c8db56825ae71d6d79447849e617115f4a920fa2acdcab2b053c4b2838bd6b71 curl command : ( HMAC SHA256 ) $ curl -H `` X-MBX-APIKEY : vmPUZE6mv9SD5VNHk4HlWFsOr6aKE2zvsw0MuIgwCIPy6utIco14y7Ju91duEh8A '' -X POST 'https : //testnet.binancefuture.com/fapi/v1/order ' -d 'symbol=BTCUSDT & side=BUY & type=LIMIT & timeInForce=GTC & quantity=1 & price=0.1 & recvWindow=5000 & timestamp=1499827319559 & signature=c8db56825ae71d6d79447849e617115f4a920fa2acdcab2b053c4b2838bd6b71' requestBody : symbol=BTCUSDT & side=BUY & type=LIMIT & timeInForce=GTC & quantity=1 & price=0.1 & recvWindow=5000 & timestamp=1499827319559 Example 3 : Mixed query string and request body Example 3 HMAC SHA256 signature : $ echo -n `` symbol=BTCUSDT & side=BUY & type=LIMIT & timeInForce=GTCquantity=1 & price=0.1 & recvWindow=5000 & timestamp=1499827319559 '' | openssl dgst -sha256 -hmac `` NhqPtmdSJYdKjVHjA7PZj4Mge3R5YNiP1e3UZjInClVN65XAbvqqM6A7H5fATj0j '' ( stdin ) = 0fd168b8ddb4876a0358a8d14d0c9f3da0e9b20c5d52b2a00fcf7d1c602f9a77 curl command : ( HMAC SHA256 ) $ curl -H `` X-MBX-APIKEY : vmPUZE6mv9SD5VNHk4HlWFsOr6aKE2zvsw0MuIgwCIPy6utIco14y7Ju91duEh8A '' -X POST 'https : //testnet.binancefuture.com/fapi/v1/order ? symbol=BTCUSDT & side=BUY & type=LIMIT & timeInForce=GTC ' -d 'quantity=1 & price=0.1 & recvWindow=5000 & timestamp=1499827319559 & signature=0fd168b8ddb4876a0358a8d14d0c9f3da0e9b20c5d52b2a00fcf7d1c602f9a77' queryString : symbol=BTCUSDT & side=BUY & type=LIMIT & timeInForce=GTC requestBody : quantity=1 & price=0.1 & recvWindow=5000 & timestamp=1499827319559 Note that the signature is different in example 3 . There is no & between `` GTC '' and `` quantity=1 '' . Public Endpoints Info Terminology base asset refers to the asset that is the quantity of a symbol . quote asset refers to the asset that is the price of a symbol . ENUM definitions Symbol type : FUTURE Order status ( status ) : NEW PARTIALLY_FILLED FILLED CANCELED REJECTED EXPIRED Order types ( orderTypes , type ) : LIMIT MARKET STOP Order side ( side ) : BUY SELL Time in force ( timeInForce ) : GTC - Good Till Cancel OC - Immediate or Cancel FOK - Fill or Kill GTX - Good Till Crossing ( Post Only ) Kline/Candlestick chart intervals : m - > minutes ; h - > hours ; d - > days ; w - > weeks ; M - > months 1m 3m 5m 15m 30m 1h 2h 4h 6h 8h 12h 1d 3d 1w 1M Rate limiters ( rateLimitType ) REQUEST_WEIGHT { `` rateLimitType '' : `` REQUEST_WEIGHT '' , `` interval '' : `` MINUTE '' , `` intervalNum '' : 1 , `` limit '' : 1200 } ORDERS { `` rateLimitType '' : `` ORDERS '' , `` interval '' : `` SECOND '' , `` intervalNum '' : 1 , `` limit '' : 10 } REQUEST_WEIGHT ORDERS Rate limit intervals ( interval ) SECOND MINUTE DAY Filters Filters define trading rules on a symbol or an exchange . Symbol filters PRICE_FILTER /exchangeInfo format : { `` filterType '' : `` PRICE_FILTER '' , `` minPrice '' : `` 0.00000100 '' , `` maxPrice '' : `` 100000.00000000 '' , `` tickSize '' : `` 0.00000100 '' } The PRICE_FILTER defines the price rules for a symbol . There are 3 parts : minPrice defines the minimum price/stopPrice allowed ; disabled on minPrice == 0. maxPrice defines the maximum price/stopPrice allowed ; disabled on maxPrice == 0. tickSize defines the intervals that a price/stopPrice can be increased/decreased by ; disabled on tickSize == 0 . Any of the above variables can be set to 0 , which disables that rule in the price filter . In order to pass the price filter , the following must be true for price/stopPrice of the enabled rules : price > = minPrice price < = maxPrice ( price-minPrice ) % tickSize == 0 LOT_SIZE /exchangeInfo format : { `` filterType '' : `` LOT_SIZE '' , `` minQty '' : `` 0.00100000 '' , `` maxQty '' : `` 100000.00000000 '' , `` stepSize '' : `` 0.00100000 '' } The LOT_SIZE filter defines the quantity ( aka `` lots '' in auction terms ) rules for a symbol . There are 3 parts : minQty defines the minimum quantity allowed . maxQty defines the maximum quantity allowed . stepSize defines the intervals that a quantity can be increased/decreased by . In order to pass the lot size , the following must be true for quantity : quantity > = minQty quantity < = maxQty ( quantity-minQty ) % stepSize == 0 MARKET_LOT_SIZE /exchangeInfo format : { `` filterType '' : `` MARKET_LOT_SIZE '' , `` minQty '' : `` 0.00100000 '' , `` maxQty '' : `` 100000.00000000 '' , `` stepSize '' : `` 0.00100000 '' } The MARKET_LOT_SIZE filter defines the quantity ( aka `` lots '' in auction terms ) rules for MARKET orders on a symbol . There are 3 parts : minQty defines the minimum quantity allowed . maxQty defines the maximum quantity allowed . stepSize defines the intervals that a quantity can be increased/decreased by . In order to pass the market lot size , the following must be true for quantity : quantity > = minQty quantity < = maxQty ( quantity-minQty ) % stepSize == 0 MAX_NUM_ORDERS /exchangeInfo format : { `` filterType '' : `` MAX_NUM_ORDERS '' , `` limit '' : 25 } The MAX_NUM_ORDERS filter defines the maximum number of orders an account is allowed to have open on a symbol . Note that both `` algo '' orders and normal orders are counted for this filter . PERCENT_PRICE ExchangeInfo format : { `` filterType '' : `` PERCENT_PRICE '' , `` multiplierUp '' : `` 1.1500 '' , `` multiplierDown '' : `` 0.8500 '' , `` multiplierDecimal '' : 4 } The PERCENT_PRICE filter defines valid range for a price based on the mark price . In order to pass the percent price , the following must be true for price : price < = markPrice * multiplierUp price > = markPrice * multiplierDown Market Data Endpoints Test Connectivity Response : { } GET /fapi/v1/ping Test connectivity to the Rest API . Weight : 1 Parameters : NONE Check Server time Response : { `` serverTime '' : 1499827319559 } GET /fapi/v1/time Test connectivity to the Rest API and get the current server time . Weight : 1 Parameters : NONE Exchange Information Response : { `` exchangeFilters '' : [ ] , `` rateLimits '' : [ { `` interval '' : `` MINUTE '' , `` intervalNum '' : 1 , `` limit '' : 6000 , `` rateLimitType '' : `` REQUEST_WEIGHT '' } , { `` interval '' : `` MINUTE '' , `` intervalNum '' : 1 , `` limit '' : 6000 , `` rateLimitType '' : `` ORDERS '' } ] , `` serverTime '' : 1565613908500 , `` symbols '' : [ { `` filters '' : [ { `` filterType '' : `` PRICE_FILTER '' , `` maxPrice '' : `` 10000000 '' , `` minPrice '' : `` 0.00000100 '' , `` tickSize '' : `` 0.00000100 '' } , { `` filterType '' : `` LOT_SIZE '' , `` maxQty '' : `` 10000000 '' , `` minQty '' : `` 0.00100000 '' , `` stepSize '' : `` 0.00100000 '' } , { `` filterType '' : `` MARKET_LOT_SIZE '' , `` maxQty '' : `` 10000000 '' , `` minQty '' : `` 0.00100000 '' , `` stepSize '' : `` 0.00100000 '' } , { `` filterType '' : `` MAX_NUM_ORDERS '' , `` limit '' : 100 } ， { `` filterType '' : `` PERCENT_PRICE '' , `` multiplierUp '' : `` 1.1500 '' , `` multiplierDown '' : `` 0.8500 '' , `` multiplierDecimal '' : 4 } ] , `` maintMarginPercent '' : `` 2.5000 '' , `` pricePrecision '' : 2 , `` quantityPrecision '' : 3 , `` requiredMarginPercent '' : `` 5.0000 '' , `` status '' : `` TRADING '' , `` OrderType '' : [ `` LIMIT '' , `` MARKET '' , `` STOP '' ] , `` symbol '' : `` BTCUSDT '' , `` timeInForce '' : [ `` GTC '' , // Good Till Cancel `` IOC '' , // Immediate or Cancel `` FOK '' , // Fill or Kill `` GTX '' // Good Till Crossing ] } ] , `` timezone '' : `` UTC '' } GET /fapi/v1/exchangeInfo Current exchange trading rules and symbol information Weight : 1 Parameters : NONE To interact with the Binance exchange , you 'll need specific information from the /fapi/v1/exchangeInfo endpoint . Key details include : Rate limits : Ensure you adhere to rate limits defined in the rateLimits array . The array contains objects related to the exchange 's RAW_REQUEST , REQUEST_WEIGHT , and ORDER rate limits . Violating rate limits may result in a 429 status code or an IP ban . Endpoint security type : You 'll need to know the security type of each endpoint you interact with . The security type determines how you will interact with the endpoint , whether through a public or signed ( TRADE and USER_DATA ) endpoint . API keys : You 'll need an API key and secret key to interact with secure endpoints . API keys can be passed into the Rest API via the X-MBX-APIKEY header . Signed endpoints : For TRADE and USER_DATA endpoints , you 'll need to include an additional 'signature ' parameter in the query string or request body . You 'll need to calculate the HMAC SHA256 signature using your secret key and the totalParams as the value . Timing security : Include a 'timestamp ' parameter with the millisecond timestamp of when the request was created and sent . You can also use the 'recvWindow ' parameter to specify the number of milliseconds the request is valid for after the timestamp . Filters : Each symbol has trading rules defined by filters such as PRICE_FILTER , LOT_SIZE , MARKET_LOT_SIZE , MAX_NUM_ORDERS , and PERCENT_PRICE . Ensure you comply with these trading rules while interacting with the exchange . ENUM definitions : Familiarize yourself with ENUM definitions for symbol types , order status , order types , order side , time in force , Kline/candlestick chart intervals , and rate limiters . By gathering the necessary information from the Binance exchange , you can efficiently interact with the platform and conduct trades or retrieve information . B . Young General API Information The base endpoint is : https : //testnet.binancefuture.com All endpoints return either a JSON object or array . Data is returned in ascending order . Oldest first , newest last . All time and timestamp related fields are in milliseconds . HTTP 4XX return codes are used for for malformed requests ; the issue is on the sender 's side . HTTP 429 return code is used when breaking a request rate limit . HTTP 418 return code is used when an IP has been auto-banned for continuing to send requests after receiving 429 codes . HTTP 5XX return codes are used for internal errors ; the issue is on Binance 's side . It is important to NOT treat this as a failure operation ; the execution status is UNKNOWN and could have been a success . Any endpoint can return an ERROR . The error payload is as follows : { `` code '' : -1121 , `` msg '' : `` Invalid symbol . '' } Specific error codes and messages defined in Error Codes . For GET endpoints , parameters must be sent as a query string . For POST , PUT , and DELETE endpoints , the parameters may be sent as a query string or in the request body with content type application/x-www-form-urlencoded . You may mix parameters between both the query string and request body if you wish to do so . Parameters may be sent in any order . If a parameter sent in both the query string and request body , the query string parameter will be used . Here is a summary of the general API information for the Binance Futures Testnet : Base endpoint : https : //testnet.binancefuture.com Responses : JSON objects or arrays , returned in ascending order ( oldest first , newest last ) . Time and timestamp fields : milliseconds . HTTP status codes : 4XX : Malformed requests ( issue on sender 's side ) . 429 : Request rate limit exceeded . 418 : IP auto-banned for continued requests after receiving 429 codes . 5XX : Internal errors ( issue on Binance 's side ) ; execution status is UNKNOWN . Error payload example : css Copy code { `` code '' : -1121 , `` msg '' : `` Invalid symbol . '' } Parameter handling : GET endpoints : Parameters sent as query strings . POST , PUT , DELETE endpoints : Parameters sent as query strings or in the request body with content type application/x-www-form-urlencoded . Parameters can be sent in any order . If a parameter is sent in both the query string and request body , the query string parameter will be used . Please note that this information applies to the Binance Futures Testnet API . The details might vary slightly for other Binance APIs , so make sure to consult the respective documentation when working with different Binance services . B . Young User Data Streams The base API endpoint is : https : //testnet.binancefuture.com A User Data Stream listenKey is valid for 30 minutes after creation . Doing a PUT on a listenKey will extend its validity for 30 minutes . Doing a DELETE on a listenKey will close the stream . The base websocket endpoint is : wss : //testnet.binancefuture.com User Data Streams are accessed at /ws/ < listenKey > User data stream payloads are not guaranteed to be in order during heavy periods ; make sure to order your updates using E Start User Data Stream ( USER_STREAM ) Response : { `` listenKey '' : `` pqia91ma19a5s61cv6a81va65sdf19v8a65a1a5s61cv6a81va65sdf19v8a65a1 '' } POST /fapi/v1/listenKey ( HMAC SHA256 ) Start a new user data stream . The stream will close after 30 minutes unless a keepalive is sent . Weight : 1 Parameters : Name Type Mandatory Description recvWindow LONG NO timestamp LONG YES Keepalive User Data Stream ( USER_STREAM ) Response : { } PUT /fapi/v1/listenKey ( HMAC SHA256 ) Keepalive a user data stream to prevent a time out . User data streams will close after 30 minutes . It 's recommended to send a ping about every 30 minutes . Weight : 1 Parameters : Name Type Mandatory Description recvWindow LONG NO timestamp LONG YES Close User Data Stream ( USER_STREAM ) Response : { } DELETE /fapi/v1/listenKey ( HMAC SHA256 ) Close out a user data stream . Weight : 1 Parameters : Name Type Mandatory Description recvWindow LONG NO timestamp LONG YES Event : Balance and Position Update Payload : { `` e '' : `` ACCOUNT_UPDATE '' , // Event Type `` E '' : 1564745798939 // Event Time `` a '' : [ { `` B '' : [ // Balances { `` a '' : '' USDT '' , // Asset `` wb '' : '' 122624 '' // Wallet Balance } , { `` a '' : '' BTC '' , `` wb '' : '' 0 '' } ] , `` P '' : [ // Positions { `` s '' : '' BTCUSDT '' , // Symbol `` pa '' : '' 1 '' , // Position Amount `` ep '' : '' 9000 '' , // Entry Price `` cr '' : '' 200 '' // ( Pre-fee ) Accumulated Realized } ] } ] } Event type is ACCOUNT_UPDATE . When balance or position get updated , will push this event . Event : Order Update Payload : { `` e '' : '' ORDER_TRADE_UPDATE '' , // Event Type `` E '' :1568879465651 , // Event Time `` o '' : { `` s '' : '' BTCUSDT '' , // Symbol `` c '' : '' TEST '' , // Client Order Id `` S '' : '' SELL '' , // Side `` o '' : '' LIMIT '' , // Order Type `` f '' : '' GTC '' , // Time in Force `` q '' : '' 0.001 '' , // Original Quantity `` p '' : '' 9910 '' , // Price `` ap '' : '' 0 '' , // Average Price `` sp '' : '' 0 '' , // Stop Price `` x '' : '' NEW '' , // Execution Type `` X '' : '' NEW '' , // Order Status `` i '' :8886774 , // Order Id `` l '' : '' 0 '' , // Order Last Filled Quantity `` z '' : '' 0 '' , // Order Filled Accumulated Quantity `` L '' : '' 0 '' , // Last Filled Price `` N '' : `` USDT '' , // Commission Asset , will not push if no commission `` n '' : `` 0 '' , // Commission , will not push if no commission `` T '' :1568879465651 , // Order Trade Time `` t '' :0 , // Trade Id `` b '' : '' 0 '' , // Bids Notional `` a '' : '' 9.91 '' // Ask Notional } } When new order created , order status changed will push such event . event type is ORDER_TRADE_UPDATE . Side BUY SELL Order Type MARKET LIMIT STOP Execution Type NEW PARTIAL_FILL FILL CANCELED REJECTED CALCULATED - Liquidation Execution EXPIRED TRADE RESTATED Order Status NEW PARTIALLY_FILLED FILLED CANCELED REPLACED STOPPED REJECTED EXPIRED NEW_INSURANCE - Liquidation with Insurance Fund NEW_ADL - Counterparty Liquidation ` Time in force GTC IOC FOK GTX Error Codes Here is the error JSON payload : { `` code '' : -1121 , `` msg '' : '' Invalid symbol . '' } Errors consist of two parts : an error code and a message . Codes are universal , but messages can vary . 10xx - General Server or Network issues -1000 UNKNOWN An unknown error occured while processing the request . -1001 DISCONNECTED Internal error ; unable to process your request . Please try again . -1002 UNAUTHORIZED You are not authorized to execute this request . -1003 TOO_MANY_REQUESTS Too many requests queued . Too many requests ; please use the websocket for live updates . Too many requests ; current limit is % s requests per minute . Please use the websocket for live updates to avoid polling the API . Way too many requests ; IP banned until % s . Please use the websocket for live updates to avoid bans . -1004 DUPLICATE_IP This IP is already on the white list -1005 NO_SUCH_IP No such IP has been white listed -1006 UNEXPECTED_RESP An unexpected response was received from the message bus . Execution status unknown . -1007 TIMEOUT Timeout waiting for response from backend server . Send status unknown ; execution status unknown . -1010 ERROR_MSG_RECEIVED ERROR_MSG_RECEIVED . -1011 NON_WHITE_LIST This IP can not access this route . -1013 ILLEGAL_MESSAGE INVALID_MESSAGE . -1014 UNKNOWN_ORDER_COMPOSITION Unsupported order combination . -1015 TOO_MANY_ORDERS Too many new orders . Too many new orders ; current limit is % s orders per % s . -1016 SERVICE_SHUTTING_DOWN This service is no longer available . -1020 UNSUPPORTED_OPERATION This operation is not supported . -1021 INVALID_TIMESTAMP Timestamp for this request is outside of the recvWindow . Timestamp for this request was 1000ms ahead of the server 's time . -1022 INVALID_SIGNATURE Signature for this request is not valid . 11xx - Request issues -1100 ILLEGAL_CHARS Illegal characters found in a parameter . Illegal characters found in parameter ' % s ' ; legal range is ' % s ' . -1101 TOO_MANY_PARAMETERS Too many parameters sent for this endpoint . Too many parameters ; expected ' % s ' and received ' % s ' . Duplicate values for a parameter detected . -1102 MANDATORY_PARAM_EMPTY_OR_MALFORMED A mandatory parameter was not sent , was empty/null , or malformed . Mandatory parameter ' % s ' was not sent , was empty/null , or malformed . Param ' % s ' or ' % s ' must be sent , but both were empty/null ! -1103 UNKNOWN_PARAM An unknown parameter was sent . -1104 UNREAD_PARAMETERS Not all sent parameters were read . Not all sent parameters were read ; read ' % s ' parameter ( s ) but was sent ' % s ' . -1105 PARAM_EMPTY A parameter was empty . Parameter ' % s ' was empty . -1106 PARAM_NOT_REQUIRED A parameter was sent when not required . Parameter ' % s ' sent when not required . -1108 BAD_ASSET Invalid asset . -1109 BAD_ACCOUNT Invalid account . -1110 BAD_INSTRUMENT_TYPE Invalid symbolType . -1111 BAD_PRECISION Precision is over the maximum defined for this asset . -1112 NO_DEPTH No orders on book for symbol . -1113 WITHDRAW_NOT_NEGATIVE Withdrawal amount must be negative . -1114 TIF_NOT_REQUIRED TimeInForce parameter sent when not required . -1115 INVALID_TIF Invalid timeInForce . -1116 INVALID_ORDER_TYPE Invalid orderType . -1117 INVALID_SIDE Invalid side . -1118 EMPTY_NEW_CL_ORD_ID New client order ID was empty . -1119 EMPTY_ORG_CL_ORD_ID Original client order ID was empty . -1120 BAD_INTERVAL Invalid interval . -1121 BAD_SYMBOL Invalid symbol . -1125 INVALID_LISTEN_KEY This listenKey does not exist . -1127 MORE_THAN_XX_HOURS Lookup interval is too big . More than % s hours between startTime and endTime . -1128 OPTIONAL_PARAMS_BAD_COMBO Combination of optional parameters invalid . -1130 INVALID_PARAMETER Invalid data sent for a parameter . Data sent for paramter ' % s ' is not valid . -2008 BAD_API_ID Invalid Api-Key ID -2010 NEW_ORDER_REJECTED NEW_ORDER_REJECTED -2011 CANCEL_REJECTED CANCEL_REJECTED -2013 NO_SUCH_ORDER Order does not exist . -2014 BAD_API_KEY_FMT API-key format invalid . -2015 REJECTED_MBX_KEY Invalid API-key , IP , or permissions for action . -2016 NO_TRADING_WINDOW No trading window could be found for the symbol . Try ticker/24hrs instead . -4000 INVALID_ORDER_STATUS Invalid order status . -4001 PRICE_LESS_THAN_ZERO Price less than 0 . -4002 PRICE_GREATER_THAN_MAX_PRICE Price greater than max price . -4003 QTY_LESS_THAN_ZERO Quantity less than zero . -4004 QTY_LESS_THAN_MIN_QTY Quantity less than min quantity . -4005 QTY_GREATER_THAN_MAX_QTY Quantity greater than max quantity . -4006 STOP_PRICE_LESS_THAN_ZERO Stop price less than zero . -4006 STOP_PRICE_GREATER_THAN_MAX_PRICE Stop price greater than max price . Messages for -1010 ERROR_MSG_RECEIVED , -2010 NEW_ORDER_REJECTED , and -2011 CANCEL_REJECTED This code is sent when an error has been returned by the matching engine . The following messages which will indicate the specific error : Error message Description '' Unknown order sent . '' The order ( by either orderId , clientOrderId , origClientOrderId ) could not be found '' Duplicate order sent . '' The clientOrderId is already in use '' Market is closed . '' The symbol is not trading '' Account has insufficient balance for requested action . '' Not enough funds to complete the action '' Market orders are not supported for this symbol . '' MARKET is not enabled on the symbol '' Stop loss orders are not supported for this symbol . '' STOP_LOSS is not enabled on the symbol '' Stop loss limit orders are not supported for this symbol . '' STOP_LOSS_LIMIT is not enabled on the symbol '' Take profit orders are not supported for this symbol . '' TAKE_PROFIT is not enabled on the symbol '' Take profit limit orders are not supported for this symbol . '' TAKE_PROFIT_LIMIT is not enabled on the symbol '' Price * QTY is zero or less . '' price * quantity is too low '' This action disabled is on this account . '' Contact customer support ; some actions have been disabled on the account . `` Unsupported order combination '' The orderType , timeInForce , stopPrice combination is n't allowed . `` Order would trigger immediately . '' The order 's stop price is not valid when compared to the last traded price . `` Cancel order is invalid . Check origClientOrderId and orderId . '' No origClientOrderId or orderId was sent in . `` Order would immediately match and take . '' LIMIT_MAKER order type would immediately match and trade , and not be a pure maker order . -9xxx Filter failures Error message Description '' Filter failure : PRICE_FILTER '' price is too high , too low , and/or not following the tick size rule for the symbol . `` Filter failure : LOT_SIZE '' quantity is too high , too low , and/or not following the step size rule for the symbol . `` Filter failure : MARKET_LOT_SIZE '' MARKET order 's quantity is too high , too low , and/or not following the step size rule for the symbol . `` Filter failure : MAX_NUM_ORDERS '' Account has too many open orders on the symbol . User Data Streams : Base API endpoint : https : //testnet.binancefuture.com Base websocket endpoint : wss : //testnet.binancefuture.com User Data Streams are accessed at /ws/ < listenKey > A listenKey is valid for 30 minutes after creation . PUT extends validity by 30 minutes , and DELETE closes the stream . Events : Balance and Position Update ( ACCOUNT_UPDATE ) , Order Update ( ORDER_TRADE_UPDATE ) User Data Stream endpoints : Start User Data Stream ( POST /fapi/v1/listenKey ) Keepalive User Data Stream ( PUT /fapi/v1/listenKey ) Close User Data Stream ( DELETE /fapi/v1/listenKey ) Order-related attributes : Side : BUY , SELL Order Type : MARKET , LIMIT , STOP Execution Type : NEW , PARTIAL_FILL , FILL , CANCELED , REJECTED , CALCULATED , EXPIRED , TRADE , RESTATED Order Status : NEW , PARTIALLY_FILLED , FILLED , CANCELED , REPLACED , STOPPED , REJECTED , EXPIRED , NEW_INSURANCE , NEW_ADL Time in force : GTC , IOC , FOK , GTX Error codes : General Server or Network issues : 10xx Request issues : 11xx Filter failures : 9xxx Error messages provide specific information about the error encountered . B . Young What additional API key information would be useful from Binance ? In addition to the information provided , the following API key information from Binance might be useful : API Key Management : How to create , view , and delete API keys from your Binance account . How to set and update API key permissions ( trading , withdrawals , etc. ) . Rate Limits : Information about the request rate limits for the Binance API , both for the REST API and the Websocket API . How the rate limits are calculated ( e.g. , weight-based , number of requests per minute ,