etc. ) . Recommendations for handling rate limit errors or avoiding them altogether . API Key Security Best Practices : Guidelines for securely storing and using your API keys . IP whitelisting and other security measures provided by Binance . Error Handling and Troubleshooting : Best practices for handling errors , timeouts , and unexpected responses from the Binance API . Tips for debugging and resolving issues with API requests . API Versioning and Updates : Information about Binance API versioning and how to handle updates or changes to the API . Binance API Libraries : Official and community-supported libraries for various programming languages , which can simplify the process of interacting with the Binance API . Examples and Use Cases : Sample code and practical examples demonstrating how to use the Binance API for various tasks , such as placing orders , fetching account information , or streaming market data . Having access to this additional information would enable you to better understand and utilize the B B . Young Test Connectivity Response : { } GET /fapi/v1/ping Test connectivity to the Rest API . Weight : 1 Parameters : NONE Check Server time Response : { `` serverTime '' : 1499827319559 } GET /fapi/v1/time Test connectivity to the Rest API and get the current server time . Weight : 1 Parameters : NONE Exchange Information Response : { `` exchangeFilters '' : [ ] , `` rateLimits '' : [ { `` interval '' : `` MINUTE '' , `` intervalNum '' : 1 , `` limit '' : 6000 , `` rateLimitType '' : `` REQUEST_WEIGHT '' } , { `` interval '' : `` MINUTE '' , `` intervalNum '' : 1 , `` limit '' : 6000 , `` rateLimitType '' : `` ORDERS '' } ] , `` serverTime '' : 1565613908500 , `` symbols '' : [ { `` filters '' : [ { `` filterType '' : `` PRICE_FILTER '' , `` maxPrice '' : `` 10000000 '' , `` minPrice '' : `` 0.00000100 '' , `` tickSize '' : `` 0.00000100 '' } , { `` filterType '' : `` LOT_SIZE '' , `` maxQty '' : `` 10000000 '' , `` minQty '' : `` 0.00100000 '' , `` stepSize '' : `` 0.00100000 '' } , { `` filterType '' : `` MARKET_LOT_SIZE '' , `` maxQty '' : `` 10000000 '' , `` minQty '' : `` 0.00100000 '' , `` stepSize '' : `` 0.00100000 '' } , { `` filterType '' : `` MAX_NUM_ORDERS '' , `` limit '' : 100 } ， { `` filterType '' : `` PERCENT_PRICE '' , `` multiplierUp '' : `` 1.1500 '' , `` multiplierDown '' : `` 0.8500 '' , `` multiplierDecimal '' : 4 } ] , `` maintMarginPercent '' : `` 2.5000 '' , `` pricePrecision '' : 2 , `` quantityPrecision '' : 3 , `` requiredMarginPercent '' : `` 5.0000 '' , `` status '' : `` TRADING '' , `` OrderType '' : [ `` LIMIT '' , `` MARKET '' , `` STOP '' ] , `` symbol '' : `` BTCUSDT '' , `` timeInForce '' : [ `` GTC '' , // Good Till Cancel `` IOC '' , // Immediate or Cancel `` FOK '' , // Fill or Kill `` GTX '' // Good Till Crossing ] } ] , `` timezone '' : `` UTC '' } GET /fapi/v1/exchangeInfo Current exchange trading rules and symbol information Weight : 1 Parameters : NONE Order Book Response : { `` lastUpdateId '' : 1027024 , `` bids '' : [ [ `` 4.00000000 '' , // PRICE `` 431.00000000 '' // QTY ] ] , `` asks '' : [ [ `` 4.00000200 '' , `` 12.00000000 '' ] ] } GET /fapi/v1/depth Weight : Adjusted based on the limit : Limit Weight 5 , 10 , 20 , 50 , 100 1 500 5 1000 10 Parameters : Name Type Mandatory Description symbol STRING YES limit INT NO Default 100 ; max 1000 . Valid limits : [ 5 , 10 , 20 , 50 , 100 , 500 , 1000 ] Recent Trades List Response : [ { `` id '' : 28457 , `` price '' : `` 4.00000100 '' , `` qty '' : `` 12.00000000 '' , `` quoteQty '' : `` 8000.00 '' , `` time '' : 1499865549590 , `` isBuyerMaker '' : true , } ] GET /fapi/v1/trades Get recent trades ( up to last 500 ) . Weight : 1 Parameters : Name Type Mandatory Description symbol STRING YES limit INT NO Default 500 ; max 1000 . Old Trades Lookup Response : [ { `` id '' : 28457 , `` price '' : `` 4.00000100 '' , `` qty '' : `` 12.00000000 '' , `` quoteQty '' : `` 8000.00 '' , `` time '' : 1499865549590 , `` isBuyerMaker '' : true , } ] GET /fapi/v1/historicalTrades Get older market historical trades . Weight : 5 Parameters : Name Type Mandatory Description symbol STRING YES limit INT NO Default 500 ; max 1000. fromId LONG NO TradeId to fetch from . Default gets most recent trades . X-MBX-APIKEY required Compressed/Aggregate Trades List Response : [ { `` a '' : 26129 , // Aggregate tradeId `` p '' : `` 0.01633102 '' , // Price `` q '' : `` 4.70443515 '' , // Quantity `` f '' : 27781 , // First tradeId `` l '' : 27781 , // Last tradeId `` T '' : 1498793709153 , // Timestamp `` m '' : true , // Was the buyer the maker ? } ] GET /fapi/v1/aggTrades Get compressed , aggregate trades . Trades that fill at the time , from the same order , with the same price will have the quantity aggregated . Weight : 1 Parameters : Name Type Mandatory Description symbol STRING YES fromId LONG NO ID to get aggregate trades from INCLUSIVE . startTime LONG NO Timestamp in ms to get aggregate trades from INCLUSIVE . endTime LONG NO Timestamp in ms to get aggregate trades until INCLUSIVE . limit INT NO Default 500 ; max 1000 . If both startTime and endTime are sent , time between startTime and endTime must be less than 1 hour . If fromId , startTime , and endTime are not sent , the most recent aggregate trades will be returned . Kline/Candlestick Data Response : [ [ 1499040000000 , // Open time `` 0.01634790 '' , // Open `` 0.80000000 '' , // High `` 0.01575800 '' , // Low `` 0.01577100 '' , // Close `` 148976.11427815 '' , // Volume 1499644799999 , // Close time `` 2434.19055334 '' , // Quote asset volume 308 , // Number of trades `` 1756.87402397 '' , // Taker buy base asset volume `` 28.46694368 '' , // Taker buy quote asset volume `` 17928899.62484339 '' // Ignore. ] ] GET /fapi/v1/klines Kline/candlestick bars for a symbol . Klines are uniquely identified by their open time . Weight : 1 Parameters : Name Type Mandatory Description symbol STRING YES interval ENUM YES startTime LONG NO endTime LONG NO limit INT NO Default 500 ; max 1500 . If startTime and endTime are not sent , the most recent klines are returned . Mark Price Response : { `` symbol '' : `` BTCUSDT '' , `` markPrice '' : `` 11012.80409769 '' , `` lastFundingRate '' : `` -0.03750000 '' , `` nextFundingTime '' : 1562569200000 , `` time '' : 1562566020000 } GET /fapi/v1/premiumIndex Mark Price and Funding Rate Weight : 1 Parameters : Name Type Mandatory Description symbol STRING YES 24hr Ticker Price Change Statistics Response : { `` symbol '' : `` BTCUSDT '' , `` priceChange '' : `` -94.99999800 '' , `` priceChangePercent '' : `` -95.960 '' , `` weightedAvgPrice '' : `` 0.29628482 '' , `` prevClosePrice '' : `` 0.10002000 '' , `` lastPrice '' : `` 4.00000200 '' , `` lastQty '' : `` 200.00000000 '' , `` openPrice '' : `` 99.00000000 '' , `` highPrice '' : `` 100.00000000 '' , `` lowPrice '' : `` 0.10000000 '' , `` volume '' : `` 8913.30000000 '' , `` quoteVolume '' : `` 15.30000000 '' , `` openTime '' : 1499783499040 , `` closeTime '' : 1499869899040 , `` firstId '' : 28385 , // First tradeId `` lastId '' : 28460 , // Last tradeId `` count '' : 76 // Trade count } OR [ { `` symbol '' : `` BTCUSDT '' , `` priceChange '' : `` -94.99999800 '' , `` priceChangePercent '' : `` -95.960 '' , `` weightedAvgPrice '' : `` 0.29628482 '' , `` prevClosePrice '' : `` 0.10002000 '' , `` lastPrice '' : `` 4.00000200 '' , `` lastQty '' : `` 200.00000000 '' , `` openPrice '' : `` 99.00000000 '' , `` highPrice '' : `` 100.00000000 '' , `` lowPrice '' : `` 0.10000000 '' , `` volume '' : `` 8913.30000000 '' , `` quoteVolume '' : `` 15.30000000 '' , `` openTime '' : 1499783499040 , `` closeTime '' : 1499869899040 , `` firstId '' : 28385 , // First tradeId `` lastId '' : 28460 , // Last tradeId `` count '' : 76 // Trade count } ] GET /fapi/v1/ticker/24hr 24 hour rolling window price change statistics . Careful when accessing this with no symbol . Weight : 1 for a single symbol ; 40 when the symbol parameter is omitted Parameters : Name Type Mandatory Description symbol STRING NO If the symbol is not sent , tickers for all symbols will be returned in an array . Symbol Price Ticker Response : { `` symbol '' : `` BTCUSDT '' , `` price '' : `` 6000.01 '' } OR [ { `` symbol '' : `` BTCUSDT '' , `` price '' : `` 6000.01 '' } ] GET /fapi/v1/ticker/price Latest price for a symbol or symbols . Weight : 1 for a single symbol ; 2 when the symbol parameter is omitted Parameters : Name Type Mandatory Description symbol STRING NO If the symbol is not sent , prices for all symbols will be returned in an array . Symbol Order Book Ticker Response : { `` symbol '' : `` BTCUSDT '' , `` bidPrice '' : `` 4.00000000 '' , `` bidQty '' : `` 431.00000000 '' , `` askPrice '' : `` 4.00000200 '' , `` askQty '' : `` 9.00000000 '' } OR [ { `` symbol '' : `` BTCUSDT '' , `` bidPrice '' : `` 4.00000000 '' , `` bidQty '' : `` 431.00000000 '' , `` askPrice '' : `` 4.00000200 '' , `` askQty '' : `` 9.00000000 '' } ] GET /fapi/v1/ticker/bookTicker Best price/qty on the order book for a symbol or symbols . Weight : 1 for a single symbol ; 2 when the symbol parameter is omitted Parameters : Name Type Mandatory Description symbol STRING NO If the symbol is not sent , bookTickers for all symbols will be returned in an array . Here are some useful endpoints for Binance Futures API : Test Connectivity Endpoint : ` B . Young The base endpoint is : wss : //testnet.binancefuture.com Streams can be access either in a single raw stream or a combined stream Raw streams are accessed at /ws/ < streamName > Combined streams are accessed at /stream ? streams= < streamName1 > / < streamName2 > / < streamName3 > Combined stream events are wrapped as follows : { `` stream '' : '' < streamName > '' , '' data '' : < rawPayload > } All symbols for streams are lowercase The websocket server will send a ping frame every 3 minutes . If the websocket server does not receive a pong frame back from the connection within a 10 minute period , the connection will be disconnected . Unsolicited pong frames are allowed . Aggregate Trade Streams Payload : { `` e '' : `` aggTrade '' , // Event type `` E '' : 123456789 , // Event time `` s '' : `` BTCUSDT '' , // Symbol `` p '' : `` 0.001 '' , // Price `` q '' : `` 100 '' , // Quantity `` f '' : 100 , // First trade ID `` l '' : 105 , // Last trade ID `` T '' : 123456785 , // Trade time `` m '' : true , // Is the buyer the market maker ? } The Aggregate Trade Streams push trade information that is aggregated for a single taker order every 100 milliseconds . Stream Name : < symbol > @ aggTrade Mark Price Stream Payload : { `` e '' : `` markPriceUpdate '' , // Event type `` E '' : 1562305380000 , // Event time `` s '' : `` BTCUSDT '' , // Symbol `` p '' : `` 11185.87786614 '' , // Mark price `` r '' : `` 0.00030000 '' , // Funding rate `` T '' : 1562306400000 // Next funding time } Mark price for a single symbol pushed every 3 secends . Stream Name : < symbol > @ markPrice Kline/Candlestick Streams Payload : { `` e '' : `` kline '' , // Event type `` E '' : 123456789 , // Event time `` s '' : `` BTCUSDT '' , // Symbol `` k '' : { `` t '' : 123400000 , // Kline start time `` T '' : 123460000 , // Kline close time `` s '' : `` BTCUSDT '' , // Symbol `` i '' : `` 1m '' , // Interva\ `` f '' : 100 , // First trade ID `` L '' : 200 , // Last trade ID `` o '' : `` 0.0010 '' , // Open price `` c '' : `` 0.0020 '' , // Close price `` h '' : `` 0.0025 '' , // High price `` l '' : `` 0.0015 '' , // Low price `` v '' : `` 1000 '' , // Base asset volume `` n '' : 100 , // Number of trades `` x '' : false , // Is this kline closed ? `` q '' : `` 1.0000 '' , // Quote asset volume `` V '' : `` 500 '' , // Taker buy base asset volume `` Q '' : `` 0.500 '' , // Taker buy quote asset volume `` B '' : `` 123456 '' // Ignore } } The Kline/Candlestick Stream push updates to the current klines/candlestick every 250 milliseconds ( if existing ) . Kline/Candlestick chart intervals : m - > minutes ; h - > hours ; d - > days ; w - > weeks ; M - > months 1m 3m 5m 15m 30m 1h 2h 4h 6h 8h 12h 1d 3d 1w 1M Stream Name : < symbol > @ kline_ < interval > Individual Symbol Mini Ticker Stream Payload : { `` e '' : `` 24hrMiniTicker '' , // Event type `` E '' : 123456789 , // Event time `` s '' : `` BTCUSDT '' , // Symbol `` c '' : `` 0.0025 '' , // Close price `` o '' : `` 0.0010 '' , // Open price `` h '' : `` 0.0025 '' , // High price `` l '' : `` 0.0010 '' , // Low price `` v '' : `` 10000 '' , // Total traded base asset volume `` q '' : `` 18 '' // Total traded quote asset volume } 24hr rolling window mini-ticker statistics for a single symbol pushed every 3 seconds . These are NOT the statistics of the UTC day , but a 24hr rolling window from requestTime to 24hrs before . Stream Name : < symbol > @ miniTicker Individual Symbol Ticker Streams Payload : { `` e '' : `` 24hrTicker '' , // Event type `` E '' : 123456789 , // Event time `` s '' : `` BTCUSDT '' , // Symbol `` p '' : `` 0.0015 '' , // Price change `` P '' : `` 250.00 '' , // Price change percent `` w '' : `` 0.0018 '' , // Weighted average price `` c '' : `` 0.0025 '' , // Last price `` Q '' : `` 10 '' , // Last quantity `` o '' : `` 0.0010 '' , // Open price `` h '' : `` 0.0025 '' , // High price `` l '' : `` 0.0010 '' , // Low price `` v '' : `` 10000 '' , // Total traded base asset volume `` q '' : `` 18 '' , // Total traded quote asset volume `` O '' : 0 , // Statistics open time `` C '' : 86400000 , // Statistics close time `` F '' : 0 , // First trade ID `` L '' : 18150 , // Last trade Id `` n '' : 18151 // Total number of trades } 24hr rollwing window ticker statistics for a single symbol pushed every 3 seconds . These are NOT the statistics of the UTC day , but a 24hr rolling window from requestTime to 24hrs before . Stream Name : < symbol > @ ticker Partial Book Depth Streams Payload : { `` e '' : `` depthUpdate '' , // Event type `` E '' : 123456789 , // Event time `` s '' : `` BTCUSDT '' , // Symbol `` U '' : 157 , // first update Id from last stream `` u '' : 160 , // last update Id from last stream `` pu '' : 149 , // last update Id in last stream（ie ‘ u ’ in last stream） `` b '' : [ // Bids to be updated [ `` 0.0024 '' , // Price level to be updated `` 10 '' // Quantity ] ] , `` a '' : [ // Asks to be updated [ `` 0.0026 '' , // Price level to be updated `` 100 '' // Quantity ] ] } Bids and asks , pushed every 250 milliseconds ( if existing ) Stream Name : < symbol > @ depth How to manage a local order book correctly Open a stream to wss : //testnet.binancefuture.com/stream ? streams=btcusdt @ depth . Buffer the events you receive from the stream . For same price , latest received update covers the previous one . Get a depth snapshot from https : //testnet.binancefuture.com/fapi/v1/depth ? symbol=BTCUSDT & limit=1000 . Drop any event where u is < lastUpdateId in the snapshot The first processed event should have U < = lastUpdateId AND u > = lastUpdateId While listening to the stream , each new event 's pu should be equal to the previous event 's u , otherwise initialize the process from step 3 . The data in each event is the absolute quantity for a price level If the quantity is 0 , remove the price level Receiving an event that removes a price level that is not in your local order book can happen and is normal . To work with the Binance Futures API Websockets B . Young New Order ( TRADE ) Response : { `` accountId '' : 10012 , `` clientOrderId '' : `` testOrder '' , `` cumQuote '' : `` 0 '' , `` executedQty '' : `` 0 '' , `` orderId '' : 22542179 , `` origQty '' : `` 10 '' , `` price '' : `` 10000 '' , `` side '' : `` SELL '' , `` status '' : `` NEW '' , `` stopPrice '' : `` 0 '' , `` symbol '' : `` BTCUSDT '' , `` timeInForce '' : `` GTC '' , `` type '' : `` LIMIT '' , `` updateTime '' : 1566818724722 } POST /fapi/v1/order ( HMAC SHA256 ) Send in a new order . Weight : 1 Parameters : Name Type Mandatory Description symbol STRING YES side ENUM YES type ENUM YES timeInForce ENUM NO quantity DECIMAL YES price DECIMAL NO newClientOrderId STRING NO A unique id for the order . Automatically generated if not sent . stopPrice DECIMAL NO Used with STOP orders . recvWindow LONG NO timestamp LONG YES Additional mandatory parameters based on type : Type Additional mandatory parameters LIMIT timeInForce , quantity , price MARKET quantity STOP quantity , price , stopPrice Order with type MARKET , parameter timeInForce can not be sent . Order with type STOP , parameter timeInForce can be sent ( default GTC ) . Query Order ( USER_DATA ) Response : { `` symbol '' : `` BTCUSDT '' , `` orderId '' : 1 , `` clientOrderId '' : `` myOrder1 '' , `` price '' : `` 0.1 '' , `` origQty '' : `` 1.0 '' , `` executedQty '' : `` 0.0 '' , `` cumQuote '' : `` 0.0 '' , `` status '' : `` NEW '' , `` timeInForce '' : `` GTC '' , `` type '' : `` LIMIT '' , `` side '' : `` BUY '' , `` stopPrice '' : `` 0.0 '' , `` time '' : 1499827319559 , `` updateTime '' : 1499827319559 } GET /fapi/v1/order ( HMAC SHA256 ) Check an order 's status . Weight : 1 Parameters : Name Type Mandatory Description symbol STRING YES orderId LONG NO origClientOrderId STRING NO recvWindow LONG NO timestamp LONG YES Notes : Either orderId or origClientOrderId must be sent . Cancel Order ( TRADE ) Response : { `` symbol '' : `` BTCUSDT '' , `` orderId '' : 28 , `` origClientOrderId '' : `` myOrder1 '' , `` clientOrderId '' : `` cancelMyOrder1 '' , `` transactTime '' : 1507725176595 , `` price '' : `` 1.00000000 '' , `` origQty '' : `` 10.00000000 '' , `` executedQty '' : `` 8.00000000 '' , `` cumQuote '' : `` 8.00000000 '' , `` status '' : `` CANCELED '' , `` timeInForce '' : `` GTC '' , `` type '' : `` LIMIT '' , `` side '' : `` SELL '' } DELETE /fapi/v1/order ( HMAC SHA256 ) Cancel an active order . Weight : 1 Parameters : Name Type Mandatory Description symbol STRING YES orderId LONG NO origClientOrderId STRING NO Automatically generated by default . recvWindow LONG NO timestamp LONG YES Either orderId or origClientOrderId must be sent . Current Open Orders ( USER_DATA ) Response : [ { `` symbol '' : `` BTCUSDT '' , `` orderId '' : 1 , `` clientOrderId '' : `` myOrder1 '' , `` accountId '' : 1 , `` price '' : `` 0.1 '' , `` origQty '' : `` 1.0 '' , `` cumQty '' : `` 1.0 '' , `` cumQuote '' : `` 1.0 '' , `` status '' : `` NEW '' , `` timeInForce '' : `` GTC '' , `` type '' : `` LIMIT '' , `` side '' : `` BUY '' , `` stopPrice '' : `` 0.0 '' , `` updateTime '' : 1499827319559 } ] GET /fapi/v1/openOrders ( HMAC SHA256 ) Get all open orders on a symbol . Careful when accessing this with no symbol . Weight : 1 for a single symbol ; 40 when the symbol parameter is omitted Parameters : Name Type Mandatory Description symbol STRING NO recvWindow LONG NO timestamp LONG YES If the symbol is not sent , orders for all symbols will be returned in an array . All Orders ( USER_DATA ) Response : [ { `` symbol '' : `` BTCUSDT '' , `` orderId '' : 1 , `` clientOrderId '' : `` myOrder1 '' , `` price '' : `` 0.1 '' , `` origQty '' : `` 1.0 '' , `` executedQty '' : `` 1.0 '' , `` cumQuote '' : `` 10.0 '' , `` status '' : `` NEW '' , `` timeInForce '' : `` GTC '' , `` type '' : `` LIMIT '' , `` side '' : `` BUY '' , `` stopPrice '' : `` 0.0 '' , `` updateTime '' : 1499827319559 } ] GET /fapi/v1/allOrders ( HMAC SHA256 ) Get all account orders ; active , canceled , or filled . Weight : 5 with symbol Parameters : Name Type Mandatory Description symbol STRING YES orderId LONG NO startTime LONG NO endTime LONG NO limit INT NO Default 500 ; max 1000. recvWindow LONG NO timestamp LONG YES Notes : If orderId is set , it will get orders > = that orderId . Otherwise most recent orders are returned . Account Information ( USER_DATA ) Response : { `` assets '' : [ { `` asset '' : `` USDT '' , `` initialMargin '' : `` 9.00000000 '' , `` maintMargin '' : `` 0.00000000 '' , `` marginBalance '' : `` 22.12659734 '' , `` maxWithdrawAmount '' : `` 13.12659734 '' , `` openOrderInitialMargin '' : `` 9.00000000 '' , `` positionInitialMargin '' : `` 0.00000000 '' , `` unrealizedProfit '' : `` 0.00000000 '' , `` walletBalance '' : `` 22.12659734 '' } ] , `` canDeposit '' : True , `` canTrade '' : True , `` canWithdraw '' : True , `` feeTier '' : 0 , `` maxWithdrawAmount '' : `` 13.12659734 '' , `` totalInitialMargin '' : `` 9.00000000 '' , `` totalMaintMargin '' : `` 0.00000000 '' , `` totalMarginBalance '' : `` 22.12659734 '' , `` totalOpenOrderInitialMargin '' : u '' 9.00000000 '' , `` totalPositionInitialMargin '' : u '' 0.00000000 '' , `` totalUnrealizedProfit '' : u '' 0.00000000 '' , `` totalWalletBalance '' : u '' 22.12659734 '' , `` updateTime '' : 0 } GET /fapi/v1/account ( HMAC SHA256 ) Get current account information . Weight : 5 Parameters : Name Type Mandatory Description recvWindow LONG NO timestamp LONG YES Position Information ( USER_DATA ) Response : [ { `` entryPrice '' : `` 9975.12000 '' , `` liquidationPrice '' : `` 7963.54 '' , `` markPrice '' : `` 9973.50770517 '' , `` positionAmt '' : `` 0.010 '' , `` symbol '' : `` BTCUSDT '' , `` unRealizedProfit '' : `` -0.01612295 '' } ] GET /fapi/v1/positionRisk ( HMAC SHA256 ) Get current account information . Weight : 5 Parameters : Name Type Mandatory Description recvWindow LONG NO timestamp LONG YES Account Trade List ( USER_DATA ) Response : [ { `` symbol '' : `` BTCUSDT '' , `` id '' : 28457 , `` orderId '' : 100234 , `` price '' : `` 4.00000100 '' , `` qty '' : `` 12.00000000 '' , `` quoteQty '' : `` 48.000012 '' , `` commission '' : `` 10.10000000 '' , `` commissionAsset '' : `` USDT '' , `` time '' : 1499865549590 , `` isBuyer '' : true , `` isMaker '' : false , } ] GET /fapi/v1/userTrades ( HMAC SHA256 ) Get trades for a specific account and symbol . Weight : 5 with symbol Parameters : Name Type Mandatory Description symbol STRING YES startTime LONG NO endTime LONG NO fromId LONG NO TradeId to fetch from . Default gets most recent trades . limit INT NO Default 500 ; max 1000. recvWindow LONG NO timestamp LONG YES Notes : If fromId is set , it will get orders > = that fromId . Otherwise most recent orders are returned . User Data Streams The base API endpoint is : https : //testnet.binancefuture.com A User Data Stream listenKey is valid for 30 minutes after creation . Doing a PUT on a listenKey will extend its validity for 30 minutes . Doing a DELETE on a listenKey will close the stream . The base websocket endpoint is : wss : //testnet.binancefuture.com User Data Streams are accessed at /ws/ < listenKey > User data stream payloads are not guaranteed to be in order during heavy periods ; make sure to order your updates using E The User Data Streams provide real-time updates on trades , orders , and account balances . To use the User Data Stream , B . Young Is the information I provided regarding Binance exchange API allow for a clear expectation of the API requirements ? Yes , the information you provided about the Binance exchange API gives a clear understanding of the API requirements , including various endpoints , request parameters , and response structures . It covers essential operations like placing , querying , and canceling orders , and retrieving account and position information . This comprehensive overview helps developers familiarize themselves with the Binance API , making it easier for them to integrate it into their applications or trading bots . The examples provided with each endpoint make it easier to understand the expected input and output formats , and the descriptions of various parameters and weights offer valuable insight into the API 's usage and limitations . B . Young Can you provide an example however that information can be applied to the Crypto Trading bot ? Certainly ! Here 's an example of how you could use the Binance API information to create a simple Python-based crypto trading bot using the requests library for making API calls and websocket for handling the user data stream . First , you 'll need B . Young How do I apply the binance api information to the current version of the Crypto trading bot ? I thought I had to do something with the binance API for the trading bot to be able to interact with it My apologies for the confusion . To apply the Binance API information to your existing crypto trading bot , you 'll need to integrate the Binance API into your bot 's code . Here 's a step-by-step guide on how to do this using the ccxt library in Python : Install the ccxt library : bash Copy code pip install ccxt Import the library and initialize the Binance exchange : python Copy code import ccxt exchange = ccxt.binance ( { 'apiKey ' : 'YOUR_API_KEY ' , 'secret ' : 'YOUR_SECRET_KEY ' , 'enableRateLimit ' : True , # To respect rate limits } ) Replace 'YOUR_API_KEY ' and 'YOUR_SECRET_KEY ' with your actual Binance API key and secret . Retrieve your account balance : python Copy code balance = exchange.fetch_balance ( ) print ( balance ) Place a limit order : python Copy code symbol = 'BTC/USDT' side = 'buy' price = 10000 amount = 0.01 order = exchange.create_limit_order ( symbol , side , price , amount ) print ( order ) Get open orders : python Copy code open_orders = exchange.fetch_open_orders ( symbol ) print ( open_orders ) Cancel an order : python Copy code order_id = 'your_order_id' cancelled_order = exchange.cancel_order ( order_id , symbol ) print ( cancelled_order ) Replace 'your_order_id ' with the actual order ID you want to cancel . Get your trade history : python Copy code trades = exchange.fetch_my_trades ( symbol ) print ( trades ) You can now integrate these functions into your existing crypto trading bot to interact with the Binance API . Make sure to adapt the functions to your bot 's logic and strategy . B . Young Can you adjust your examples to interact with the AI/Machine language portion of the program to place trades and make actions for trading based on conclusions made through the analysis of the data collected from the key sources ? 2 / 2 Sure ! Here 's an example of how to integrate the Binance API with a simple AI/machine learning model to make trading decisions . We 'll use a basic moving average strategy for demonstration purposes . Note that this is a simple example B . Young What am I working on now ? Based on your previous questions , you are currently working on integrating the Binance API with a simple AI/machine learning model to create a crypto trading bot . The bot will collect data from the Binance API , analyze the data using the AI/machine learning component , and then make trading decisions based on the conclusions drawn from the analysis . In the previous response , I provided an example of how to use a moving average strategy with the Binance API . If you need further assistance or have more specific requirements , feel free to ask additional questions . B . Young How do I combine the current Trading bot build to binance ? Can you provide a functional example of the code as it would be in the current build ? To combine the current trading bot build with the Binance API , you 'll need to install the Binance API Python package , implement the trading strategy , and then integrate the strategy with the Binance API to fetch market data and execute trades . Here 's a functional example using a simple moving average crossover strategy : Install the Binance Python package : Copy code pip install python-binance Create a file named binance_trading_bot.py and add the following code : python Copy code import os from binance import Client import pandas as pd import numpy as np import time API_KEY = os.environ.get ( 'BINANCE_API_KEY ' ) API_SECRET = os.environ.get ( 'BINANCE_SECRET_KEY ' ) client = Client ( API_KEY , API_SECRET ) def fetch_historical_data ( symbol , interval , limit ) : klines = client.get_klines ( symbol=symbol , interval=interval , limit=limit ) data = pd.DataFrame ( klines , columns= [ 'timestamp ' , 'open ' , 'high ' , 'low ' , 'close ' , 'volume ' , 'close_time ' , 'quote_av ' , 'trades ' , 'tb_base_av ' , 'tb_quote_av ' , 'ignore ' ] ) data [ 'timestamp ' ] = pd.to_datetime ( data [ 'timestamp ' ] , unit='ms ' ) data.set_index ( 'timestamp ' , inplace=True ) data = data.astype ( float ) return data def moving_average ( data , window ) : return data [ 'close ' ] .rolling ( window=window ) .mean ( ) def trading_strategy ( symbol , interval , short_window , long_window , limit=500 ) : data = fetch_historical_data ( symbol , interval , limit ) data [ 'short_mavg ' ] = moving_average ( data , short_window ) data [ 'long_mavg ' ] = moving_average ( data , long_window ) data [ 'signal ' ] = np.where ( data [ 'short_mavg ' ] > data [ 'long_mavg ' ] , 1 , 0 ) return data def execute_trade ( symbol , signal , quantity ) : if signal == 1 : # Buy order = client.order_market_buy ( symbol=symbol , quantity=quantity ) elif signal == -1 : # Sell order = client.order_market_sell ( symbol=symbol , quantity=quantity ) return order if __name__ == `` __main__ '' : symbol = 'BTCUSDT' interval = Client.KLINE_INTERVAL_15MINUTE short_window = 50 long_window = 200 trade_quantity = 0.001 while True : data = trading_strategy ( symbol , interval , short_window , long_window ) current_signal = data [ 'signal ' ] .iloc [ -1 ] previous_signal = data [ 'signal ' ] .iloc [ -2 ] if current_signal ! = previous_signal : if current_signal == 1 : # Buy print ( `` Buying : '' , trade_quantity , `` BTC '' ) execute_trade ( symbol , current_signal , trade_quantity ) elif current_signal == 0 : # Sell print ( `` Selling : '' , trade_quantity , `` BTC '' ) execute_trade ( symbol , -1 , trade_quantity ) time.sleep ( 15 * 60 ) # Sleep for 15 minutes Replace 'BINANCE_API_KEY ' and 'BINANCE_SECRET_KEY ' with your own API keys . This example uses a simple moving average crossover strategy . The bot fetches historical data using the Binance API , calculates short and long moving averages , generates buy/sell signals based on the moving averages , and then executes trades accordingly . Note that this is a basic example and should not be used for real trading without proper testing and enhancements . It 's essential to test the strategy with historical data and incorporate proper risk management , error handling , and trade execution logic . You can modify the strategy , intervals , B . Young Can this be included in the Crypto Trading package ? Yes , you can integrate this code into the existing Crypto Trading package . Here 's how you can achieve that : First , add the Binance API Python package to your project 's requirements.txt file : Copy code python-binance In your Crypto Trading package , create a new file named binance_connector.py and add the following code : python Copy code import os from binance import Client import pandas as pd import numpy as np API_KEY = os.environ.get ( 'BINANCE_API_KEY ' ) API_SECRET = os.environ.get ( 'BINANCE_SECRET_KEY ' ) client = Client ( API_KEY , API_SECRET ) def fetch_historical_data ( symbol , interval , limit ) : klines = client.get_klines ( symbol=symbol , interval=interval , limit=limit ) data = pd.DataFrame ( klines , columns= [ 'timestamp ' , 'open ' , 'high ' , 'low ' , 'close ' , 'volume ' , 'close_time ' , 'quote_av ' , 'trades ' , 'tb_base_av ' , 'tb_quote_av ' , 'ignore ' ] ) data [ 'timestamp ' ] = pd.to_datetime ( data [ 'timestamp ' ] , unit='ms ' ) data.set_index ( 'timestamp ' , inplace=True ) data = data.astype ( float ) return data def execute_trade ( symbol , signal , quantity ) : if signal == 1 : # Buy order = client.order_market_buy ( symbol=symbol , quantity=quantity ) elif signal == -1 : # Sell order = client.order_market_sell ( symbol=symbol , quantity=quantity ) return order Now , in your main trading bot file , import the binance_connector and use its functions to fetch historical data and execute trades . Replace the existing functions for fetching data and executing trades with the Binance-specific functions from binance_connector . Here 's an example of how you can modify the main trading bot file : python Copy code import time from trading_strategies import moving_average_cross_strategy from binance_connector import fetch_historical_data , execute_trade symbol = 'BTCUSDT' interval = '15m' short_window = 50 long_window = 200 trade_quantity = 0.001 while True : data = fetch_historical_data ( symbol , interval ) signal = moving_average_cross_strategy ( data , short_window , long_window ) if signal ! = 0 : print ( `` Executing trade with signal : '' , signal ) execute_trade ( symbol , signal , trade_quantity ) time.sleep ( 15 * 60 ) # Sleep for 15 minutes In this example , we 've replaced the existing data-fetching and trade-execution functions with the ones provided by the binance_connector . Make sure to adjust the rest of the trading bot and strategy logic according to your specific requirements . Ensure that you replace 'BINANCE_API_KEY ' and 'BINANCE_SECRET_KEY ' with your own API keys , and consider using a configuration file or environment variables for better security . Please note that this is a basic example and should not be used for real trading without proper testing and enhancements . It 's essential to test the strategy with historical data and incorporate proper risk management , error handling , and trade execution logic . B . Young can you display the full 'requirments.txt ' file ? Certainly ! Here 's an example of a requirements.txt file for the Crypto Trading package : Copy code numpy pandas python-binance These are the required packages for the example provided in the previous responses : numpy : A popular library for working with arrays and numerical operations in Python . pandas : A library that offers data manipulation and analysis tools , particularly for working with DataFrames . python-binance : The official Binance API client for Python , which allows interaction with the Binance exchange . You might need to add more dependencies depending on your specific trading strategies , data processing needs , or other features you plan to implement in your trading bot . B . Young Can you display the full main.py code with the updates ? Here is the updated main.py code that incorporates the Binance API and the AI/ML trading strategy : python Copy code import numpy as np import pandas as pd from binance.client import Client from binance.enums import * from ai_strategy import AITradingStrategy # Binance API keys api_key = `` your_api_key '' api_secret = `` your_api_secret '' # Initialize the Binance client client = Client ( api_key , api_secret ) # Instantiate the AI trading strategy ai_strategy = AITradingStrategy ( ) # Get historical data for analysis symbol = `` BTCUSDT '' interval = Client.KLINE_INTERVAL_30MINUTE historical_data = client.get_historical_klines ( symbol , interval , `` 30 days ago UTC '' ) # Convert historical data to a pandas DataFrame historical_df = pd.DataFrame ( historical_data , columns= [ 'open_time ' , 'open ' , 'high ' , 'low ' , 'close ' , 'volume ' , 'close_time ' , 'quote_asset_volume ' , 'number_of_trades ' , 'taker_buy_base_asset_volume ' , 'taker_buy_quote_asset_volume ' , 'ignore ' ] ) historical_df [ 'open_time ' ] = pd.to_datetime ( historical_df [ 'open_time ' ] , unit='ms ' ) # Analyze the historical data using AI/ML ai_strategy.analyze_data ( historical_df ) # Make a trading decision based on the analysis decision = ai_strategy.make_decision ( ) # Execute the decision if decision == `` buy '' : order = client.create_order ( symbol=symbol , side=SIDE_BUY , type=ORDER_TYPE_MARKET , quantity=0.001 # Adjust the quantity based on your desired investment ) print ( `` Order executed : BUY '' ) elif decision == `` sell '' : order = client.create_order ( symbol=symbol , side=SIDE_SELL , type=ORDER_TYPE_MARKET , quantity=0.001 # Adjust the quantity based on the amount of the asset you own ) print ( `` Order executed : SELL '' ) else : print ( `` No action taken . '' ) This updated main.py file includes the Binance API , historical data retrieval , AI/ML trading strategy analysis , and order execution based on the trading decision . Remember to replace your_api_key and your_api_secret with your actual Binance API keys . You should also adjust the order quantity based on your desired investment or the amount of the asset you own . Note : The AITradingStrategy class should be implemented in the ai_strategy.py file to make this code work . You can customize the AI/ML strategy by modifying the analyze_data ( ) and make_decision ( ) methods in the AITradingStrategy class . B . Young Wait , did we develop anything for the `` ai trading strategy '' ? My apologies for the confusion . In the previous responses , I provided an outline of how to integrate the Binance API with a hypothetical AI/ML trading strategy . However , I did not provide any actual implementation for the AITradingStrategy class . Let 's create a simple example of the AITradingStrategy class using a moving average crossover strategy . Here 's a basic implementation of the AITradingStrategy class in ai_strategy.py : python Copy code import pandas as pd class AITradingStrategy : def __init__ ( self ) : self.short_window = 20 self.long_window = 50 def analyze_data ( self , historical_df ) : historical_df [ 'short_mavg ' ] = historical_df [ 'close ' ] .rolling ( window=self.short_window ) .mean ( ) historical_df [ 'long_mavg ' ] = historical_df [ 'close ' ] .rolling ( window=self.long_window ) .mean ( ) self.historical_df = historical_df def make_decision ( self ) : if self.historical_df.iloc [ -1 ] [ 'short_mavg ' ] > self.historical_df.iloc [ -1 ] [ 'long_mavg ' ] : return `` buy '' elif self.historical_df.iloc [ -1 ] [ 'short_mavg ' ] < self.historical_df.iloc [ -1 ] [ 'long_mavg ' ] : return `` sell '' else : return `` hold '' This simple example uses a moving average crossover strategy . The analyze_data ( ) method calculates the short and long moving averages of the closing prices in the historical data . The make_decision ( ) method compares the most recent short and long moving averages to decide whether to buy , sell , or hold . Keep in mind that this is just a simple example and may not be suitable for actual trading . You can further develop and improve the AI/ML trading strategy by incorporating more sophisticated algorithms , indicators , and machine learning models . B . Young Based on the trading strategy we discussed before , how could the 'AITradingStrategy '' be developed and designed so it works for what we want ? To develop the AITradingStrategy class to work with the previously discussed trading bot , we 'll need to follow these steps : Modify the AITradingStrategy class to accept relevant indicators , parameters , and models . Develop methods for preprocessing , analyzing , and predicting actions based on the input data . Integrate the AITradingStrategy class with the trading bot . Here 's an example implementation for the AITradingStrategy class : python Copy code import pandas as pd import numpy as np from sklearn.ensemble import RandomForestClassifier from sklearn.preprocessing import StandardScaler from sklearn.model_selection import train_test_split class AITradingStrategy : def __init__ ( self , historical_df , indicators , model=None ) : self.historical_df = historical_df self.indicators = indicators self.model = model if model else RandomForestClassifier ( ) def preprocess_data ( self ) : # Add your selected indicators to the historical data for indicator in self.indicators : self.historical_df = indicator ( self.historical_df ) # Remove rows with NaN values self.historical_df.dropna ( inplace=True ) # Prepare data for training self.X = self.historical_df.iloc [ : , : -1 ] self.y = self.historical_df.iloc [ : , -1 ] # Scale data scaler = StandardScaler ( ) self.X = scaler.fit_transform ( self.X ) # Split data into training and testing sets self.X_train , self.X_test , self.y_train , self.y_test = train_test_split ( self.X , self.y , test_size=0.2 , random_state=42 ) def train_model ( self ) : self.model.fit ( self.X_train , self.y_train ) def predict_action ( self , latest_data ) : # Preprocess the latest data for indicator in self.indicators : latest_data = indicator ( latest_data ) latest_data.dropna ( inplace=True ) # Scale the latest data using the same scaler as before latest_X = scaler.transform ( latest_data.iloc [ : , : -1 ] ) # Predict the action action = self.model.predict ( latest_X ) return action In this example , we use a RandomForestClassifier as the default model , but you can replace it with any suitable AI/ML model . The class now accepts historical data , indicators , and an optional model . The preprocess_data ( ) method calculates the indicators , scales the data , and splits it into training and testing sets . The train_model ( ) method trains the AI/ML model on the preprocessed data . The predict_action ( ) method preprocesses the latest data and predicts the action based on the trained model . To integrate this AITradingStrategy class with your trading bot , you 'll need to : Import the AITradingStrategy class in your main.py file . Instantiate the AITradingStrategy object with historical data , indicators , and an optional model . Preprocess the data , train the model , and make predictions using the methods provided in the class . Use the predicted actions to make buy or sell decisions in your trading bot . Please note that the example provided is a simple illustration and might not be suitable for real-world trading . Be sure to optimize and validate your AI/ML models and strategies thoroughly before using them in a live trading environment . B . Young So with the other parts of the trading package , will this code block be able to analyze market data to make trades based on the requirments in the trading strategy and risk management plan ? The current code block serves as a starting point and demonstrates a basic implementation of an AI trading strategy using a RandomForestClassifier . It is designed to process historical data , train the AI/ML model , and make predictions on new data . However , the example provided is quite simplistic and might not be suitable for real-world trading . To make the code more effective and tailored to your specific trading strategy and risk management plan , you need to : Enhance the AI/ML model : Replace the RandomForestClassifier with a more advanced AI/ML model or fine-tune the existing model using hyperparameter optimization . You can explore other models like LSTM ( Long Short-Term Memory ) networks or reinforcement learning algorithms . Feature engineering : Improve the selection of indicators and other features in